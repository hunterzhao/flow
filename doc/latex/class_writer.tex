\hypertarget{class_writer}{}\section{Writer$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$ Class Template Reference}
\label{class_writer}\index{Writer$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$@{Writer$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$}}


J\+S\+ON writer.  




{\ttfamily \#include $<$writer.\+h$>$}

Inheritance diagram for Writer$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.025641cm]{class_writer}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_writer_1_1_level}{Level}
\begin{DoxyCompactList}\small\item\em Information for each nested level. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Source\+Encoding\+::\+Ch {\bfseries Ch}\hypertarget{class_writer_ab08bff5fd2daec65f4a78779ca3d2139}{}\label{class_writer_ab08bff5fd2daec65f4a78779ca3d2139}

\item 
typedef Source\+Encoding\+::\+Ch {\bfseries Ch}\hypertarget{class_writer_ab08bff5fd2daec65f4a78779ca3d2139}{}\label{class_writer_ab08bff5fd2daec65f4a78779ca3d2139}

\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_writer_af4f54830d6927d9daf5bd53bfd134dd3}{Writer} (Output\+Stream \&os, Stack\+Allocator $\ast$stack\+Allocator=0, size\+\_\+t level\+Depth=k\+Default\+Level\+Depth)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
{\bfseries Writer} (Stack\+Allocator $\ast$allocator=0, size\+\_\+t level\+Depth=k\+Default\+Level\+Depth)\hypertarget{class_writer_a7b885cea71542fc436be80eff447fb64}{}\label{class_writer_a7b885cea71542fc436be80eff447fb64}

\item 
void \hyperlink{class_writer_a8b53e8f137f7fcf694f5500711b3f58d}{Reset} (Output\+Stream \&os)
\begin{DoxyCompactList}\small\item\em Reset the writer with a new stream. \end{DoxyCompactList}\item 
bool \hyperlink{class_writer_a446cfad4b88cfd69b1b63d57989f2e76}{Is\+Complete} () const 
\begin{DoxyCompactList}\small\item\em Checks whether the output is a complete J\+S\+ON. \end{DoxyCompactList}\item 
int {\bfseries Get\+Max\+Decimal\+Places} () const \hypertarget{class_writer_abbd76fd072c7feca94ddb0a02fb6e44b}{}\label{class_writer_abbd76fd072c7feca94ddb0a02fb6e44b}

\item 
void \hyperlink{class_writer_a58e3f94dc5af1432a8eace5ba427eca7}{Set\+Max\+Decimal\+Places} (int max\+Decimal\+Places)
\begin{DoxyCompactList}\small\item\em Sets the maximum number of decimal places for double output. \end{DoxyCompactList}\item 
bool \hyperlink{class_writer_ae0d1615104e4e88040b9640e6784008a}{Raw\+Value} (const Ch $\ast$json, size\+\_\+t length, Type type)
\begin{DoxyCompactList}\small\item\em Write a raw J\+S\+ON value. \end{DoxyCompactList}\item 
\hyperlink{class_writer_af4f54830d6927d9daf5bd53bfd134dd3}{Writer} (Output\+Stream \&os, Stack\+Allocator $\ast$stack\+Allocator=0, size\+\_\+t level\+Depth=k\+Default\+Level\+Depth)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
{\bfseries Writer} (Stack\+Allocator $\ast$allocator=0, size\+\_\+t level\+Depth=k\+Default\+Level\+Depth)\hypertarget{class_writer_a7b885cea71542fc436be80eff447fb64}{}\label{class_writer_a7b885cea71542fc436be80eff447fb64}

\item 
void \hyperlink{class_writer_a8b53e8f137f7fcf694f5500711b3f58d}{Reset} (Output\+Stream \&os)
\begin{DoxyCompactList}\small\item\em Reset the writer with a new stream. \end{DoxyCompactList}\item 
bool \hyperlink{class_writer_a446cfad4b88cfd69b1b63d57989f2e76}{Is\+Complete} () const 
\begin{DoxyCompactList}\small\item\em Checks whether the output is a complete J\+S\+ON. \end{DoxyCompactList}\item 
int {\bfseries Get\+Max\+Decimal\+Places} () const \hypertarget{class_writer_abbd76fd072c7feca94ddb0a02fb6e44b}{}\label{class_writer_abbd76fd072c7feca94ddb0a02fb6e44b}

\item 
void \hyperlink{class_writer_a58e3f94dc5af1432a8eace5ba427eca7}{Set\+Max\+Decimal\+Places} (int max\+Decimal\+Places)
\begin{DoxyCompactList}\small\item\em Sets the maximum number of decimal places for double output. \end{DoxyCompactList}\item 
bool \hyperlink{class_writer_ae0d1615104e4e88040b9640e6784008a}{Raw\+Value} (const Ch $\ast$json, size\+\_\+t length, Type type)
\begin{DoxyCompactList}\small\item\em Write a raw J\+S\+ON value. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{Indent}{\bf Implementation of Handler}\par
{\em \begin{DoxySeeAlso}{See also}
Handler 
\end{DoxySeeAlso}
}\begin{DoxyCompactItemize}
\item 
bool {\bfseries Null} ()\hypertarget{class_writer_af700ed03c8810d48a4aaa3c5baeaf26c}{}\label{class_writer_af700ed03c8810d48a4aaa3c5baeaf26c}

\item 
bool {\bfseries Bool} (bool b)\hypertarget{class_writer_ad7491f4dedb02e7456b240b23ef8c1ad}{}\label{class_writer_ad7491f4dedb02e7456b240b23ef8c1ad}

\item 
bool {\bfseries Int} (int i)\hypertarget{class_writer_ad471415aa7741e732bab0bcfbb9522a8}{}\label{class_writer_ad471415aa7741e732bab0bcfbb9522a8}

\item 
bool {\bfseries Uint} (unsigned u)\hypertarget{class_writer_a5fb0c3228f89f6f9bef15f3e6e6f1739}{}\label{class_writer_a5fb0c3228f89f6f9bef15f3e6e6f1739}

\item 
bool {\bfseries Int64} (int64\+\_\+t i64)\hypertarget{class_writer_a4144d7086ed9d3d807c373de242bde45}{}\label{class_writer_a4144d7086ed9d3d807c373de242bde45}

\item 
bool {\bfseries Uint64} (uint64\+\_\+t u64)\hypertarget{class_writer_a55bb9f286ecdaf4cdb07bddb02e0cb2d}{}\label{class_writer_a55bb9f286ecdaf4cdb07bddb02e0cb2d}

\item 
bool \hyperlink{class_writer_a22a43e8a7193105deec6b808736f7a1a}{Double} (double d)
\begin{DoxyCompactList}\small\item\em Writes the given {\ttfamily double} value to the stream. \end{DoxyCompactList}\item 
bool {\bfseries Raw\+Number} (const Ch $\ast$str, Size\+Type length, bool copy=false)\hypertarget{class_writer_ad462dc606fddea0f34fc0e190c3bdaee}{}\label{class_writer_ad462dc606fddea0f34fc0e190c3bdaee}

\item 
bool {\bfseries String} (const Ch $\ast$str, Size\+Type length, bool copy=false)\hypertarget{class_writer_a8b4dc44f471403a83c9959575796ceab}{}\label{class_writer_a8b4dc44f471403a83c9959575796ceab}

\item 
bool {\bfseries Start\+Object} ()\hypertarget{class_writer_aec3200b2fc80ec87d1c37f775256b2e1}{}\label{class_writer_aec3200b2fc80ec87d1c37f775256b2e1}

\item 
bool {\bfseries Key} (const Ch $\ast$str, Size\+Type length, bool copy=false)\hypertarget{class_writer_a19096d2ccb90761f63ab1240337bf90a}{}\label{class_writer_a19096d2ccb90761f63ab1240337bf90a}

\item 
bool {\bfseries End\+Object} (Size\+Type member\+Count=0)\hypertarget{class_writer_a0771a565261564c27676b7300b11f2b5}{}\label{class_writer_a0771a565261564c27676b7300b11f2b5}

\item 
bool {\bfseries Start\+Array} ()\hypertarget{class_writer_a38715785194b42cd67ba5dd52bf7967e}{}\label{class_writer_a38715785194b42cd67ba5dd52bf7967e}

\item 
bool {\bfseries End\+Array} (Size\+Type element\+Count=0)\hypertarget{class_writer_ac88d533095591a878500b63b351d4013}{}\label{class_writer_ac88d533095591a878500b63b351d4013}

\item 
bool {\bfseries Null} ()\hypertarget{class_writer_af700ed03c8810d48a4aaa3c5baeaf26c}{}\label{class_writer_af700ed03c8810d48a4aaa3c5baeaf26c}

\item 
bool {\bfseries Bool} (bool b)\hypertarget{class_writer_ad7491f4dedb02e7456b240b23ef8c1ad}{}\label{class_writer_ad7491f4dedb02e7456b240b23ef8c1ad}

\item 
bool {\bfseries Int} (int i)\hypertarget{class_writer_ad471415aa7741e732bab0bcfbb9522a8}{}\label{class_writer_ad471415aa7741e732bab0bcfbb9522a8}

\item 
bool {\bfseries Uint} (unsigned u)\hypertarget{class_writer_a5fb0c3228f89f6f9bef15f3e6e6f1739}{}\label{class_writer_a5fb0c3228f89f6f9bef15f3e6e6f1739}

\item 
bool {\bfseries Int64} (int64\+\_\+t i64)\hypertarget{class_writer_a4144d7086ed9d3d807c373de242bde45}{}\label{class_writer_a4144d7086ed9d3d807c373de242bde45}

\item 
bool {\bfseries Uint64} (uint64\+\_\+t u64)\hypertarget{class_writer_a55bb9f286ecdaf4cdb07bddb02e0cb2d}{}\label{class_writer_a55bb9f286ecdaf4cdb07bddb02e0cb2d}

\item 
bool \hyperlink{class_writer_a22a43e8a7193105deec6b808736f7a1a}{Double} (double d)
\begin{DoxyCompactList}\small\item\em Writes the given {\ttfamily double} value to the stream. \end{DoxyCompactList}\item 
bool {\bfseries Raw\+Number} (const Ch $\ast$str, Size\+Type length, bool copy=false)\hypertarget{class_writer_ad462dc606fddea0f34fc0e190c3bdaee}{}\label{class_writer_ad462dc606fddea0f34fc0e190c3bdaee}

\item 
bool {\bfseries String} (const Ch $\ast$str, Size\+Type length, bool copy=false)\hypertarget{class_writer_a8b4dc44f471403a83c9959575796ceab}{}\label{class_writer_a8b4dc44f471403a83c9959575796ceab}

\item 
bool {\bfseries Start\+Object} ()\hypertarget{class_writer_aec3200b2fc80ec87d1c37f775256b2e1}{}\label{class_writer_aec3200b2fc80ec87d1c37f775256b2e1}

\item 
bool {\bfseries Key} (const Ch $\ast$str, Size\+Type length, bool copy=false)\hypertarget{class_writer_a19096d2ccb90761f63ab1240337bf90a}{}\label{class_writer_a19096d2ccb90761f63ab1240337bf90a}

\item 
bool {\bfseries End\+Object} (Size\+Type member\+Count=0)\hypertarget{class_writer_a0771a565261564c27676b7300b11f2b5}{}\label{class_writer_a0771a565261564c27676b7300b11f2b5}

\item 
bool {\bfseries Start\+Array} ()\hypertarget{class_writer_a38715785194b42cd67ba5dd52bf7967e}{}\label{class_writer_a38715785194b42cd67ba5dd52bf7967e}

\item 
bool {\bfseries End\+Array} (Size\+Type element\+Count=0)\hypertarget{class_writer_ac88d533095591a878500b63b351d4013}{}\label{class_writer_ac88d533095591a878500b63b351d4013}

\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Convenience extensions}\par
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{class_writer_a24eb1a72b42da5fe51ff99d9c293dd11}{String} (const Ch $\ast$str)\hypertarget{class_writer_a24eb1a72b42da5fe51ff99d9c293dd11}{}\label{class_writer_a24eb1a72b42da5fe51ff99d9c293dd11}

\begin{DoxyCompactList}\small\item\em Simpler but slower overload. \end{DoxyCompactList}\item 
bool {\bfseries Key} (const Ch $\ast$str)\hypertarget{class_writer_a8a40514efe951801df6896a596ed8563}{}\label{class_writer_a8a40514efe951801df6896a596ed8563}

\item 
bool \hyperlink{class_writer_a24eb1a72b42da5fe51ff99d9c293dd11}{String} (const Ch $\ast$str)\hypertarget{class_writer_a24eb1a72b42da5fe51ff99d9c293dd11}{}\label{class_writer_a24eb1a72b42da5fe51ff99d9c293dd11}

\begin{DoxyCompactList}\small\item\em Simpler but slower overload. \end{DoxyCompactList}\item 
bool {\bfseries Key} (const Ch $\ast$str)\hypertarget{class_writer_a8a40514efe951801df6896a596ed8563}{}\label{class_writer_a8a40514efe951801df6896a596ed8563}

\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const int {\bfseries k\+Default\+Max\+Decimal\+Places} = 324\hypertarget{class_writer_a62cd900eb8391e9423f45375b0ebf3b0}{}\label{class_writer_a62cd900eb8391e9423f45375b0ebf3b0}

\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
bool {\bfseries Write\+Null} ()\hypertarget{class_writer_a44862b3eba8d84b909c69aba875c9f4d}{}\label{class_writer_a44862b3eba8d84b909c69aba875c9f4d}

\item 
bool {\bfseries Write\+Bool} (bool b)\hypertarget{class_writer_a42ad68b6950431bb8ca0199568546eaf}{}\label{class_writer_a42ad68b6950431bb8ca0199568546eaf}

\item 
bool {\bfseries Write\+Int} (int i)\hypertarget{class_writer_a31d0feda654ca245c41462be7dc59998}{}\label{class_writer_a31d0feda654ca245c41462be7dc59998}

\item 
bool {\bfseries Write\+Uint} (unsigned u)\hypertarget{class_writer_a2861227e93707d1478d2cf56644dca3b}{}\label{class_writer_a2861227e93707d1478d2cf56644dca3b}

\item 
bool {\bfseries Write\+Int64} (int64\+\_\+t i64)\hypertarget{class_writer_aa58d3f80c06394648de5055ecfb41587}{}\label{class_writer_aa58d3f80c06394648de5055ecfb41587}

\item 
bool {\bfseries Write\+Uint64} (uint64\+\_\+t u64)\hypertarget{class_writer_ad07b325157220e3aa791c1c8c904021e}{}\label{class_writer_ad07b325157220e3aa791c1c8c904021e}

\item 
bool {\bfseries Write\+Double} (double d)\hypertarget{class_writer_ae7a0fc4740681d845d92c1213bd25aa1}{}\label{class_writer_ae7a0fc4740681d845d92c1213bd25aa1}

\item 
bool {\bfseries Write\+String} (const Ch $\ast$str, Size\+Type length)\hypertarget{class_writer_acda4412ef5f4cac6e89f9544e4b10f70}{}\label{class_writer_acda4412ef5f4cac6e89f9544e4b10f70}

\item 
bool {\bfseries Scan\+Write\+Unescaped\+String} (\hyperlink{struct_generic_string_stream}{Generic\+String\+Stream}$<$ Source\+Encoding $>$ \&is, size\+\_\+t length)\hypertarget{class_writer_a94140803bba7863a1b39c936bbe6d262}{}\label{class_writer_a94140803bba7863a1b39c936bbe6d262}

\item 
bool {\bfseries Write\+Start\+Object} ()\hypertarget{class_writer_a81c72a2eecd47e042f56ca93a27a5cb1}{}\label{class_writer_a81c72a2eecd47e042f56ca93a27a5cb1}

\item 
bool {\bfseries Write\+End\+Object} ()\hypertarget{class_writer_a7e3f6760a50a72f4217a9b2d625c43ee}{}\label{class_writer_a7e3f6760a50a72f4217a9b2d625c43ee}

\item 
bool {\bfseries Write\+Start\+Array} ()\hypertarget{class_writer_a3c3560a96cac58f98f4a74d6cb227204}{}\label{class_writer_a3c3560a96cac58f98f4a74d6cb227204}

\item 
bool {\bfseries Write\+End\+Array} ()\hypertarget{class_writer_aabda2df1be6e83cef416e9b1f042e8f4}{}\label{class_writer_aabda2df1be6e83cef416e9b1f042e8f4}

\item 
bool {\bfseries Write\+Raw\+Value} (const Ch $\ast$json, size\+\_\+t length)\hypertarget{class_writer_a8ee1135b2595261819b134907f67614e}{}\label{class_writer_a8ee1135b2595261819b134907f67614e}

\item 
void {\bfseries Prefix} (Type type)\hypertarget{class_writer_a1fc40f8b9f3abc2548c0c5782ce1755d}{}\label{class_writer_a1fc40f8b9f3abc2548c0c5782ce1755d}

\item 
bool {\bfseries End\+Value} (bool ret)\hypertarget{class_writer_adc1cadbabc309d31f19cf7463251d879}{}\label{class_writer_adc1cadbabc309d31f19cf7463251d879}

\item 
bool {\bfseries Write\+Null} ()\hypertarget{class_writer_a44862b3eba8d84b909c69aba875c9f4d}{}\label{class_writer_a44862b3eba8d84b909c69aba875c9f4d}

\item 
bool {\bfseries Write\+Bool} (bool b)\hypertarget{class_writer_a42ad68b6950431bb8ca0199568546eaf}{}\label{class_writer_a42ad68b6950431bb8ca0199568546eaf}

\item 
bool {\bfseries Write\+Int} (int i)\hypertarget{class_writer_a31d0feda654ca245c41462be7dc59998}{}\label{class_writer_a31d0feda654ca245c41462be7dc59998}

\item 
bool {\bfseries Write\+Uint} (unsigned u)\hypertarget{class_writer_a2861227e93707d1478d2cf56644dca3b}{}\label{class_writer_a2861227e93707d1478d2cf56644dca3b}

\item 
bool {\bfseries Write\+Int64} (int64\+\_\+t i64)\hypertarget{class_writer_aa58d3f80c06394648de5055ecfb41587}{}\label{class_writer_aa58d3f80c06394648de5055ecfb41587}

\item 
bool {\bfseries Write\+Uint64} (uint64\+\_\+t u64)\hypertarget{class_writer_ad07b325157220e3aa791c1c8c904021e}{}\label{class_writer_ad07b325157220e3aa791c1c8c904021e}

\item 
bool {\bfseries Write\+Double} (double d)\hypertarget{class_writer_ae7a0fc4740681d845d92c1213bd25aa1}{}\label{class_writer_ae7a0fc4740681d845d92c1213bd25aa1}

\item 
bool {\bfseries Write\+String} (const Ch $\ast$str, Size\+Type length)\hypertarget{class_writer_acda4412ef5f4cac6e89f9544e4b10f70}{}\label{class_writer_acda4412ef5f4cac6e89f9544e4b10f70}

\item 
bool {\bfseries Scan\+Write\+Unescaped\+String} (\hyperlink{struct_generic_string_stream}{Generic\+String\+Stream}$<$ Source\+Encoding $>$ \&is, size\+\_\+t length)\hypertarget{class_writer_a94140803bba7863a1b39c936bbe6d262}{}\label{class_writer_a94140803bba7863a1b39c936bbe6d262}

\item 
bool {\bfseries Write\+Start\+Object} ()\hypertarget{class_writer_a81c72a2eecd47e042f56ca93a27a5cb1}{}\label{class_writer_a81c72a2eecd47e042f56ca93a27a5cb1}

\item 
bool {\bfseries Write\+End\+Object} ()\hypertarget{class_writer_a7e3f6760a50a72f4217a9b2d625c43ee}{}\label{class_writer_a7e3f6760a50a72f4217a9b2d625c43ee}

\item 
bool {\bfseries Write\+Start\+Array} ()\hypertarget{class_writer_a3c3560a96cac58f98f4a74d6cb227204}{}\label{class_writer_a3c3560a96cac58f98f4a74d6cb227204}

\item 
bool {\bfseries Write\+End\+Array} ()\hypertarget{class_writer_aabda2df1be6e83cef416e9b1f042e8f4}{}\label{class_writer_aabda2df1be6e83cef416e9b1f042e8f4}

\item 
bool {\bfseries Write\+Raw\+Value} (const Ch $\ast$json, size\+\_\+t length)\hypertarget{class_writer_a8ee1135b2595261819b134907f67614e}{}\label{class_writer_a8ee1135b2595261819b134907f67614e}

\item 
void {\bfseries Prefix} (Type type)\hypertarget{class_writer_a1fc40f8b9f3abc2548c0c5782ce1755d}{}\label{class_writer_a1fc40f8b9f3abc2548c0c5782ce1755d}

\item 
bool {\bfseries End\+Value} (bool ret)\hypertarget{class_writer_adc1cadbabc309d31f19cf7463251d879}{}\label{class_writer_adc1cadbabc309d31f19cf7463251d879}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Int} (int i)\hypertarget{class_writer_abefb163a93b376d056edecad5a7a82ef}{}\label{class_writer_abefb163a93b376d056edecad5a7a82ef}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Uint} (unsigned u)\hypertarget{class_writer_a9665a4a1549b286944b21927b80060cf}{}\label{class_writer_a9665a4a1549b286944b21927b80060cf}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Int64} (int64\+\_\+t i64)\hypertarget{class_writer_a3528a42394d50f3b92659de517433c85}{}\label{class_writer_a3528a42394d50f3b92659de517433c85}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Uint64} (uint64\+\_\+t u)\hypertarget{class_writer_a025b3d2ca07d539a7067575e95f5578d}{}\label{class_writer_a025b3d2ca07d539a7067575e95f5578d}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Double} (double d)\hypertarget{class_writer_af317e1d24249b8c68503a6253c703bd2}{}\label{class_writer_af317e1d24249b8c68503a6253c703bd2}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Int} (int i)\hypertarget{class_writer_abefb163a93b376d056edecad5a7a82ef}{}\label{class_writer_abefb163a93b376d056edecad5a7a82ef}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Uint} (unsigned u)\hypertarget{class_writer_a9665a4a1549b286944b21927b80060cf}{}\label{class_writer_a9665a4a1549b286944b21927b80060cf}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Int64} (int64\+\_\+t i64)\hypertarget{class_writer_a3528a42394d50f3b92659de517433c85}{}\label{class_writer_a3528a42394d50f3b92659de517433c85}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Uint64} (uint64\+\_\+t u)\hypertarget{class_writer_a025b3d2ca07d539a7067575e95f5578d}{}\label{class_writer_a025b3d2ca07d539a7067575e95f5578d}

\item 
{\footnotesize template$<$$>$ }\\bool {\bfseries Write\+Double} (double d)\hypertarget{class_writer_af317e1d24249b8c68503a6253c703bd2}{}\label{class_writer_af317e1d24249b8c68503a6253c703bd2}

\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
Output\+Stream $\ast$ {\bfseries os\+\_\+}\hypertarget{class_writer_ad24a0be4446a099a473f5f32471b13bf}{}\label{class_writer_ad24a0be4446a099a473f5f32471b13bf}

\item 
\hyperlink{classinternal_1_1_stack}{internal\+::\+Stack}$<$ Stack\+Allocator $>$ {\bfseries level\+\_\+stack\+\_\+}\hypertarget{class_writer_a285682c256cdacbe18b35a4e85b42cf4}{}\label{class_writer_a285682c256cdacbe18b35a4e85b42cf4}

\item 
int {\bfseries max\+Decimal\+Places\+\_\+}\hypertarget{class_writer_a3d4ef664c3cdf34a286b13d27adcdd4d}{}\label{class_writer_a3d4ef664c3cdf34a286b13d27adcdd4d}

\item 
bool {\bfseries has\+Root\+\_\+}\hypertarget{class_writer_affc6b9e0332b50bee0d33f8b1841c9a6}{}\label{class_writer_affc6b9e0332b50bee0d33f8b1841c9a6}

\end{DoxyCompactItemize}
\subsection*{Static Protected Attributes}
\begin{DoxyCompactItemize}
\item 
static const size\+\_\+t {\bfseries k\+Default\+Level\+Depth} = 32\hypertarget{class_writer_a0dc357519ca0c383cacecbf6911b03ad}{}\label{class_writer_a0dc357519ca0c383cacecbf6911b03ad}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Output\+Stream, typename Source\+Encoding = U\+T\+F8$<$$>$, typename Target\+Encoding = U\+T\+F8$<$$>$, typename Stack\+Allocator = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$\\*
class Writer$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$}

J\+S\+ON writer. 

\hyperlink{class_writer}{Writer} implements the concept Handler. It generates J\+S\+ON text by events to an output os.

User may programmatically calls the functions of a writer to generate J\+S\+ON text.

On the other side, a writer can also be passed to objects that generates events,

for example \hyperlink{class_generic_reader_a0c450620d14ff1824e58bb7bd9b42099}{Reader\+::\+Parse()} and Document\+::\+Accept().


\begin{DoxyTemplParams}{Template Parameters}
{\em Output\+Stream} & Type of output stream. \\
\hline
{\em Source\+Encoding} & Encoding of source string. \\
\hline
{\em Target\+Encoding} & Encoding of output stream. \\
\hline
{\em Stack\+Allocator} & Type of allocator for allocating memory of stack. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyNote}{Note}
implements Handler concept 
\end{DoxyNote}


\subsection{Constructor \& Destructor Documentation}
\index{Writer@{Writer}!Writer@{Writer}}
\index{Writer@{Writer}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Writer(\+Output\+Stream \&os, Stack\+Allocator $\ast$stack\+Allocator=0, size\+\_\+t level\+Depth=k\+Default\+Level\+Depth)}{Writer(OutputStream &os, StackAllocator *stackAllocator=0, size_t levelDepth=kDefaultLevelDepth)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::{\bf Writer} (
\begin{DoxyParamCaption}
\item[{Output\+Stream \&}]{os, }
\item[{Stack\+Allocator $\ast$}]{stack\+Allocator = {\ttfamily 0}, }
\item[{size\+\_\+t}]{level\+Depth = {\ttfamily kDefaultLevelDepth}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\hypertarget{class_writer_af4f54830d6927d9daf5bd53bfd134dd3}{}\label{class_writer_af4f54830d6927d9daf5bd53bfd134dd3}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em os} & Output stream. \\
\hline
{\em stack\+Allocator} & User supplied allocator. If it is null, it will create a private one. \\
\hline
{\em level\+Depth} & Initial capacity of stack. \\
\hline
\end{DoxyParams}
\index{Writer@{Writer}!Writer@{Writer}}
\index{Writer@{Writer}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Writer(\+Output\+Stream \&os, Stack\+Allocator $\ast$stack\+Allocator=0, size\+\_\+t level\+Depth=k\+Default\+Level\+Depth)}{Writer(OutputStream &os, StackAllocator *stackAllocator=0, size_t levelDepth=kDefaultLevelDepth)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::{\bf Writer} (
\begin{DoxyParamCaption}
\item[{Output\+Stream \&}]{os, }
\item[{Stack\+Allocator $\ast$}]{stack\+Allocator = {\ttfamily 0}, }
\item[{size\+\_\+t}]{level\+Depth = {\ttfamily kDefaultLevelDepth}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\hypertarget{class_writer_af4f54830d6927d9daf5bd53bfd134dd3}{}\label{class_writer_af4f54830d6927d9daf5bd53bfd134dd3}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em os} & Output stream. \\
\hline
{\em stack\+Allocator} & User supplied allocator. If it is null, it will create a private one. \\
\hline
{\em level\+Depth} & Initial capacity of stack. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{Writer@{Writer}!Double@{Double}}
\index{Double@{Double}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Double(double d)}{Double(double d)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ bool {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Double (
\begin{DoxyParamCaption}
\item[{double}]{d}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_a22a43e8a7193105deec6b808736f7a1a}{}\label{class_writer_a22a43e8a7193105deec6b808736f7a1a}


Writes the given {\ttfamily double} value to the stream. 


\begin{DoxyParams}{Parameters}
{\em d} & The value to be written. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether it is succeed. 
\end{DoxyReturn}
\index{Writer@{Writer}!Double@{Double}}
\index{Double@{Double}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Double(double d)}{Double(double d)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ bool {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Double (
\begin{DoxyParamCaption}
\item[{double}]{d}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_a22a43e8a7193105deec6b808736f7a1a}{}\label{class_writer_a22a43e8a7193105deec6b808736f7a1a}


Writes the given {\ttfamily double} value to the stream. 


\begin{DoxyParams}{Parameters}
{\em d} & The value to be written. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether it is succeed. 
\end{DoxyReturn}
\index{Writer@{Writer}!Is\+Complete@{Is\+Complete}}
\index{Is\+Complete@{Is\+Complete}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Is\+Complete() const }{IsComplete() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ bool {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Is\+Complete (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_a446cfad4b88cfd69b1b63d57989f2e76}{}\label{class_writer_a446cfad4b88cfd69b1b63d57989f2e76}


Checks whether the output is a complete J\+S\+ON. 

A complete J\+S\+ON has a complete root object or array. \index{Writer@{Writer}!Is\+Complete@{Is\+Complete}}
\index{Is\+Complete@{Is\+Complete}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Is\+Complete() const }{IsComplete() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ bool {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Is\+Complete (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_a446cfad4b88cfd69b1b63d57989f2e76}{}\label{class_writer_a446cfad4b88cfd69b1b63d57989f2e76}


Checks whether the output is a complete J\+S\+ON. 

A complete J\+S\+ON has a complete root object or array. \index{Writer@{Writer}!Raw\+Value@{Raw\+Value}}
\index{Raw\+Value@{Raw\+Value}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Raw\+Value(const Ch $\ast$json, size\+\_\+t length, Type type)}{RawValue(const Ch *json, size_t length, Type type)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ bool {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Raw\+Value (
\begin{DoxyParamCaption}
\item[{const Ch $\ast$}]{json, }
\item[{size\+\_\+t}]{length, }
\item[{Type}]{type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_ae0d1615104e4e88040b9640e6784008a}{}\label{class_writer_ae0d1615104e4e88040b9640e6784008a}


Write a raw J\+S\+ON value. 

For user to write a stringified J\+S\+ON as a value.


\begin{DoxyParams}{Parameters}
{\em json} & A well-\/formed J\+S\+ON value. It should not contain null character within \mbox{[}0, length -\/ 1\mbox{]} range. \\
\hline
{\em length} & Length of the json. \\
\hline
{\em type} & Type of the root of json. \\
\hline
\end{DoxyParams}
\index{Writer@{Writer}!Raw\+Value@{Raw\+Value}}
\index{Raw\+Value@{Raw\+Value}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Raw\+Value(const Ch $\ast$json, size\+\_\+t length, Type type)}{RawValue(const Ch *json, size_t length, Type type)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ bool {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Raw\+Value (
\begin{DoxyParamCaption}
\item[{const Ch $\ast$}]{json, }
\item[{size\+\_\+t}]{length, }
\item[{Type}]{type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_ae0d1615104e4e88040b9640e6784008a}{}\label{class_writer_ae0d1615104e4e88040b9640e6784008a}


Write a raw J\+S\+ON value. 

For user to write a stringified J\+S\+ON as a value.


\begin{DoxyParams}{Parameters}
{\em json} & A well-\/formed J\+S\+ON value. It should not contain null character within \mbox{[}0, length -\/ 1\mbox{]} range. \\
\hline
{\em length} & Length of the json. \\
\hline
{\em type} & Type of the root of json. \\
\hline
\end{DoxyParams}
\index{Writer@{Writer}!Reset@{Reset}}
\index{Reset@{Reset}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Reset(\+Output\+Stream \&os)}{Reset(OutputStream &os)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream , typename Source\+Encoding  = U\+T\+F8$<$$>$, typename Target\+Encoding  = U\+T\+F8$<$$>$, typename Stack\+Allocator  = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ void {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Reset (
\begin{DoxyParamCaption}
\item[{Output\+Stream \&}]{os}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_a8b53e8f137f7fcf694f5500711b3f58d}{}\label{class_writer_a8b53e8f137f7fcf694f5500711b3f58d}


Reset the writer with a new stream. 

This function reset the writer with a new stream and default settings, in order to make a \hyperlink{class_writer}{Writer} object reusable for output multiple J\+S\+O\+Ns.


\begin{DoxyParams}{Parameters}
{\em os} & New output stream. 
\begin{DoxyCode}
\hyperlink{class_writer}{Writer<OutputStream>} writer(os1);
writer.StartObject();
\textcolor{comment}{// ...}
writer.EndObject();

writer.Reset(os2);
writer.StartObject();
\textcolor{comment}{// ...}
writer.EndObject();
\end{DoxyCode}
 \\
\hline
\end{DoxyParams}
\index{Writer@{Writer}!Reset@{Reset}}
\index{Reset@{Reset}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Reset(\+Output\+Stream \&os)}{Reset(OutputStream &os)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream, typename Source\+Encoding = U\+T\+F8$<$$>$, typename Target\+Encoding = U\+T\+F8$<$$>$, typename Stack\+Allocator = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ void {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Reset (
\begin{DoxyParamCaption}
\item[{Output\+Stream \&}]{os}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_a8b53e8f137f7fcf694f5500711b3f58d}{}\label{class_writer_a8b53e8f137f7fcf694f5500711b3f58d}


Reset the writer with a new stream. 

This function reset the writer with a new stream and default settings, in order to make a \hyperlink{class_writer}{Writer} object reusable for output multiple J\+S\+O\+Ns.


\begin{DoxyParams}{Parameters}
{\em os} & New output stream. 
\begin{DoxyCode}
\hyperlink{class_writer}{Writer<OutputStream>} writer(os1);
writer.StartObject();
\textcolor{comment}{// ...}
writer.EndObject();

writer.Reset(os2);
writer.StartObject();
\textcolor{comment}{// ...}
writer.EndObject();
\end{DoxyCode}
 \\
\hline
\end{DoxyParams}
\index{Writer@{Writer}!Set\+Max\+Decimal\+Places@{Set\+Max\+Decimal\+Places}}
\index{Set\+Max\+Decimal\+Places@{Set\+Max\+Decimal\+Places}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Set\+Max\+Decimal\+Places(int max\+Decimal\+Places)}{SetMaxDecimalPlaces(int maxDecimalPlaces)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream, typename Source\+Encoding = U\+T\+F8$<$$>$, typename Target\+Encoding = U\+T\+F8$<$$>$, typename Stack\+Allocator = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ void {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Set\+Max\+Decimal\+Places (
\begin{DoxyParamCaption}
\item[{int}]{max\+Decimal\+Places}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_a58e3f94dc5af1432a8eace5ba427eca7}{}\label{class_writer_a58e3f94dc5af1432a8eace5ba427eca7}


Sets the maximum number of decimal places for double output. 

This setting truncates the output with specified number of decimal places.

For example,


\begin{DoxyCode}
writer.SetMaxDecimalPlaces(3);
writer.StartArray();
writer.Double(0.12345);                 \textcolor{comment}{// "0.123"}
writer.Double(0.0001);                  \textcolor{comment}{// "0.0"}
writer.Double(1.234567890123456e30);    \textcolor{comment}{// "1.234567890123456e30" (do not truncate significand for positive
       exponent)}
writer.Double(1.23e-4);                 \textcolor{comment}{// "0.0"                  (do truncate significand for negative
       exponent)}
writer.EndArray();
\end{DoxyCode}


The default setting does not truncate any decimal places. You can restore to this setting by calling 
\begin{DoxyCode}
writer.SetMaxDecimalPlaces(Writer::kDefaultMaxDecimalPlaces);
\end{DoxyCode}
 \index{Writer@{Writer}!Set\+Max\+Decimal\+Places@{Set\+Max\+Decimal\+Places}}
\index{Set\+Max\+Decimal\+Places@{Set\+Max\+Decimal\+Places}!Writer@{Writer}}
\subsubsection[{\texorpdfstring{Set\+Max\+Decimal\+Places(int max\+Decimal\+Places)}{SetMaxDecimalPlaces(int maxDecimalPlaces)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Output\+Stream, typename Source\+Encoding = U\+T\+F8$<$$>$, typename Target\+Encoding = U\+T\+F8$<$$>$, typename Stack\+Allocator = Crt\+Allocator, unsigned write\+Flags = k\+Write\+Default\+Flags$>$ void {\bf Writer}$<$ Output\+Stream, Source\+Encoding, Target\+Encoding, Stack\+Allocator, write\+Flags $>$\+::Set\+Max\+Decimal\+Places (
\begin{DoxyParamCaption}
\item[{int}]{max\+Decimal\+Places}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_writer_a58e3f94dc5af1432a8eace5ba427eca7}{}\label{class_writer_a58e3f94dc5af1432a8eace5ba427eca7}


Sets the maximum number of decimal places for double output. 

This setting truncates the output with specified number of decimal places.

For example,


\begin{DoxyCode}
writer.SetMaxDecimalPlaces(3);
writer.StartArray();
writer.Double(0.12345);                 \textcolor{comment}{// "0.123"}
writer.Double(0.0001);                  \textcolor{comment}{// "0.0"}
writer.Double(1.234567890123456e30);    \textcolor{comment}{// "1.234567890123456e30" (do not truncate significand for positive
       exponent)}
writer.Double(1.23e-4);                 \textcolor{comment}{// "0.0"                  (do truncate significand for negative
       exponent)}
writer.EndArray();
\end{DoxyCode}


The default setting does not truncate any decimal places. You can restore to this setting by calling 
\begin{DoxyCode}
writer.SetMaxDecimalPlaces(Writer::kDefaultMaxDecimalPlaces);
\end{DoxyCode}
 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
deps/rapidjson/fwd.\+h\item 
deps/rapidjson/writer.\+h\end{DoxyCompactItemize}
